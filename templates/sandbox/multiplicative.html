{% extends "base.html" %}
{% block title %} Multiplicative {% endblock title %}
{% block body %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplicative Cipher Encryption and Decryption</title>
    
    <style>
        /* CSS styles */
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            {% comment %} background-image: url('../static/images/bg1.png');
            filter: blur(5px); /* Adjust the blur radius as needed */
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            background-position: center; {% endcomment %}
            height: 200vh; /* Set full viewport height */
            color: white; /* Set text color to white */

        }
        .background{
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Place the background behind other content */
            background-image: url('../static/images/bg1.png');
            background-size: cover;
            background-position: center;
            filter: blur(8px); /* Apply blur effect to the background image */
        }

        .container {
            max-width: 1000px; /* Set a wider container width */
            margin: 50px auto;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent black background */
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Add a subtle box shadow */
        }

        h1 {
            text-align: center;
        }

        label {
            display: block;
            margin-bottom: 5px;
        }

        input[type="text"],
        input[type="number"],
        textarea {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            box-sizing: border-box;
            resize: none;
            overflow: auto;
            height: auto;
            border: 1px solid white; /* Set border color to white */
            border-radius: 5px;
            color: black; /* Set text color to black within input fields */
            background-color: white; /* Set background color to white within input fields */
        }

        .button-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3;
        }

        .output-container {
            display: flex;
            flex-direction: column;
            margin-top: 20px;
        }

        #explanation,
        #ciphertext,
        #decryptedtext {
            margin-top: 10px;
        }

        #step-explanation {
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            resize: none;
            height: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background-color: white; /* Set background color of table to white */
            color: black; /* Set text color of table to black */
        }

        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: center;
        }

        h1 {
            text-align: center;
            color: white; /* Set heading color to white */
        }

        p {
            color: white; /* Set paragraph text color to white */
        }
    </style>

</head>
<body>
    <div class="background"></div>
    <div class="container">
        <h1>Multiplicative Cipher Encryption and Decryption</h1>
        <p>The multiplicative cipher technique encrypts a message by multiplying the numerical value of each letter in the plaintext by the key and then taking the result modulo the key. Decryption is performed by multiplying the ciphertext by the modular multiplicative inverse of the key.</p>
        <p>The acceptable keys consist of 1,3,5,7,9,11,15,17,19,21,23,25 as they are the only numbers possessing a valid Euclidean inverse.</p>
        
        <table>
            <caption>Alphabet Table with Numeric Values</caption>
            <tr>
                <th>Alphabet</th>
                <th>Numeric Value</th>
                <th>Alphabet</th>
                <th>Numeric Value</th>
            </tr>
            <tr>
                <td>A</td>
                <td>0</td>
                <td>N</td>
                <td>13</td>
            </tr>
        </tr>
        <tr>
            <td>B</td>
            <td>1</td>
            <td>O</td>
            <td>14</td>
        </tr>
        <tr>
            <td>C</td>
            <td>2</td>
            <td>P</td>
            <td>15</td>
        </tr>
        <tr>
            <td>D</td>
            <td>3</td>
            <td>Q</td>
            <td>16</td>
        </tr>
        <tr>
            <td>E</td>
            <td>4</td>
            <td>R</td>
            <td>17</td>
        </tr>
        <tr>
            <td>F</td>
            <td>5</td>
            <td>S</td>
            <td>18</td>
        </tr>
        <tr>
            <td>G</td>
            <td>6</td>
            <td>T</td>
            <td>19</td>
        </tr>
        <tr>
            <td>H</td>
            <td>7</td>
            <td>U</td>
            <td>20</td>
        </tr>
        <tr>
            <td>I</td>
            <td>8</td>
            <td>V</td>
            <td>21</td>
        </tr>
        <tr>
            <td>J</td>
            <td>9</td>
            <td>W</td>
            <td>22</td>
        </tr>
        <tr>
            <td>K</td>
            <td>10</td>
            <td>X</td>
            <td>23</td>
        </tr>
        <tr>
            <td>L</td>
            <td>11</td>
            <td>Y</td>
            <td>24</td>
        </tr>
        <tr>
            <td>M</td>
            <td>12</td>
            <td>Z</td>
            <td>25</td>
        </tr>

        </table>

        <div>
            <label for="plaintext">Plaintext:</label>
            <input type="text" id="plaintext" placeholder="Enter plaintext...">
        </div>
        <div>
            <label for="key">Key:</label>
            <input type="number" id="key">
        </div>
        <div class="button-container">
            <button onclick="encrypt()">Encrypt</button>
            <button onclick="decrypt()">Decrypt</button>
        </div>
        <div class="output-container">
            <div id="explanation">
                <label for="step-explanation">Step-by-step explanation:</label>
                <textarea id="step-explanation" readonly></textarea>
            </div>
            <div id="ciphertext-container">
                <label for="ciphertext">Ciphertext:</label>
                <textarea id="ciphertext" readonly></textarea>
            </div>
            <div id="decryption-container">
                <label for="decryptedtext">Decrypted Text:</label>
                <textarea id="decryptedtext" readonly></textarea>
            </div>
        </div>
    </div>

    <script>
        // JavaScript code
        function encrypt() {
    var plaintext = document.getElementById("plaintext").value.toUpperCase();
    var key = parseInt(document.getElementById("key").value);
    var ciphertext = "";
    var stepByStep = ""; // Variable to store step-by-step encryption process

    // Check if the key is valid
    if (!isValidKey(key)) {
        document.getElementById("step-explanation").value = "Key Invalid";
        document.getElementById("ciphertext").value = "Encryption failed.";
        return;
    }

    for (var i = 0; i < plaintext.length; i++) {
        var charCode = plaintext.charCodeAt(i);
        if (charCode >= 65 && charCode <= 90) { // Check if character is a letter
            var x = charCode - 65; // Map A-Z to 0-25
            var encryptedCharCode = ((x * key) % 26) + 65; // Encrypt using multiplicative cipher formula
            ciphertext += String.fromCharCode(encryptedCharCode);
            // Build step-by-step explanation
            stepByStep += "Step " + (i + 1) + ": ";
            stepByStep += plaintext[i] + " -> ";
            stepByStep += "(" + x + " * " + key + ") % 26 = ";
            stepByStep += (x * key) % 26 + " -> ";
            stepByStep += String.fromCharCode(encryptedCharCode);
            stepByStep += "\n";
        } else {
            ciphertext += plaintext[i]; // Leave non-letter characters unchanged
        }
    }
    // Display step-by-step explanation
    document.getElementById("step-explanation").value = stepByStep;
    // Adjust height of explanation textarea
    adjustTextareaHeight("step-explanation");
    // Display ciphertext
    document.getElementById("ciphertext").value = ciphertext;
}

function decrypt() {
    var ciphertext = document.getElementById("ciphertext").value.toUpperCase();
    var key = parseInt(document.getElementById("key").value);
    var decryptedtext = "";
    var stepByStep = ""; // Variable to store step-by-step decryption process

    // Check if the key is valid
    if (!isValidKey(key)) {
        document.getElementById("step-explanation").value = "Key Invalid";
        document.getElementById("decryptedtext").value = "Decryption failed.";
        return;
    }

    // Find the modular multiplicative inverse of the key
    var inverseKey = findMultiplicativeInverse(key, 26);

    if (inverseKey === null) {
        // Display error if inverse does not exist
        document.getElementById("step-explanation").value = "Error: Modular multiplicative inverse does not exist for the given key and modulus (26).";
        document.getElementById("decryptedtext").value = "Decryption failed.";
        return;
    }

    for (var i = 0; i < ciphertext.length; i++) {
        var charCode = ciphertext.charCodeAt(i);
        if (charCode >= 65 && charCode <= 90) { // Check if character is a letter
            var y = charCode - 65; // Map A-Z to 0-25
            // Decrypt using multiplicative cipher formula
            var decryptedCharCode = ((y * inverseKey) % 26 + 26) % 26 + 65;
            decryptedtext += String.fromCharCode(decryptedCharCode);
            // Build step-by-step explanation
            stepByStep += "Step " + (i + 1) + ": ";
            stepByStep += ciphertext[i] + " -> ";
            stepByStep += "(" + y + " * " + inverseKey + ") % 26 = ";
            stepByStep += ((y * inverseKey) % 26 + 26) % 26 + " -> ";
            stepByStep += String.fromCharCode(decryptedCharCode);
            stepByStep += "\n";
        } else {
            decryptedtext += ciphertext[i]; // Leave non-letter characters unchanged
        }
    }
    // Display step-by-step explanation
    document.getElementById("step-explanation").value = stepByStep;
    // Adjust height of explanation textarea
    adjustTextareaHeight("step-explanation");
    // Display decrypted text
    document.getElementById("decryptedtext").value = decryptedtext;
}

// Function to check if the key is valid
function isValidKey(key) {
    var validKeys = [1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25];
    return validKeys.includes(key);
}


function decrypt() {
    var ciphertext = document.getElementById("ciphertext").value.toUpperCase();
    var key = parseInt(document.getElementById("key").value);
    var decryptedtext = "";
    var stepByStep = ""; // Variable to store step-by-step decryption process

    // Check if the key is valid
    if (!isValidKey(key)) {
        document.getElementById("step-explanation").value = "Key Invalid";
        document.getElementById("decryptedtext").value = "Decryption failed.";
        return;
    }

    // Find the modular multiplicative inverse of the key
    var inverseKey = findMultiplicativeInverse(key, 26);

    if (inverseKey === null) {
        // Display error if inverse does not exist
        document.getElementById("step-explanation").value = "Error: Modular multiplicative inverse does not exist for the given key and modulus (26).";
        document.getElementById("decryptedtext").value = "Decryption failed.";
        return;
    }

    for (var i = 0; i < ciphertext.length; i++) {
        var charCode = ciphertext.charCodeAt(i);
        if (charCode >= 65 && charCode <= 90) { // Check if character is a letter
            var y = charCode - 65; // Map A-Z to 0-25
            // Decrypt using multiplicative cipher formula
            var decryptedCharCode = ((y * inverseKey) % 26 + 26) % 26 + 65;
            decryptedtext += String.fromCharCode(decryptedCharCode);
            // Build step-by-step explanation
            stepByStep += "Step " + (i + 1) + ": ";
            stepByStep += ciphertext[i] + " -> ";
            stepByStep += "(" + y + " * " + inverseKey + ") % 26 = ";
            stepByStep += ((y * inverseKey) % 26 + 26) % 26 + " -> ";
            stepByStep += String.fromCharCode(decryptedCharCode);
            stepByStep += "\n";
        } else {
            decryptedtext += ciphertext[i]; // Leave non-letter characters unchanged
        }
    }
    // Display step-by-step explanation
    document.getElementById("step-explanation").value = stepByStep;
    // Adjust height of explanation textarea
    adjustTextareaHeight("step-explanation");
    // Display decrypted text
    document.getElementById("decryptedtext").value = decryptedtext;
}

        // Function to find the modular multiplicative inverse of a number
        function findMultiplicativeInverse(a, m) {
            a = ((a % m) + m) % m;
            for (var x = 1; x < m; x++) {
                if ((a * x) % m === 1) {
                    return x;
                }
            }
            return null; // Return null if the inverse does not exist
        }



        function adjustTextareaHeight(id) {
            var textarea = document.getElementById(id);
            textarea.style.height = "auto";
            textarea.style.height = textarea.scrollHeight + "px";
        }

        // Function to find the multiplicative inverse of a number
        function findMultiplicativeInverse(a, m) {
            for (var x = 1; x < m; x++) {
                if ((a * x) % m === 1) {
                    return x;
                }
            }
            return 1;
        }
    </script>
</body>
</html>

{% endblock body %}